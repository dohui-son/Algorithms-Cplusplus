//#include <string>
//#include <vector>
//#include <iostream>
//
//
//#include <map>
//using namespace std;
//
////
//
//
//vector<int> solution(vector<int> array) {
//    vector<int> answer;
//
//    ///
//    map<int, vector<int>>m;
//    for (int i = 0; i < array.size(); i++)
//    {
//        if (m.find(array[i]) == m.end())m.insert({ array[i],{i} });
//        else { m[array[i]].push_back(i); }
//    }
//    for (int i = 0; i < array.size(); i++)
//    {
//        if(m.find)
//
//    }
//
//    
//
//    
//    
//
//
//
//    return answer;
//}
//
//int main() {
//    vector<int> vect = { 3, 5, 4, 1, 2 };
//    solution(vect);
//    return 0;
//}
//
//
////문제 설명
////배열이 하나 입력됩니다.배열의 각 원소에 대해 해당 원소의 값보다 큰 원소들 중에서 해당 원소와 가장 가까운 위치에 있는 원소의 인덱스를 찾아주세요.
////
////조건:
////
////특정 원소에 대해, 해당 원소보다 큰 원소가 없다면 - 1을 정답으로 합니다.
////가장 가까운 원소가 하나 이상이라면, 인덱스가 가장 작은 것을 정답으로 합니다.
////각 원소는 0과 100, 000 사이의 값입니다.
////입력 배열의 길이는 0부터 100, 000 사이입니다.
////인덱스는 0부터 시작합니다.
////이 문제에는 알고리즘의 효율성을 측정하기 위한 테스트 케이스가 포함되어 있으며, 모든 테스트 케이스를 통과하려면 시간복잡도 O(n) 또는 그것보다 효과적인 알고리즘이 필요합니다.
////아래 배열을 예시로 확인해 봅시다.
////
////[3, 5, 4, 1, 2]
////가장 왼쪽 원소부터 살펴보겠습니다.
////3보다 큰 원소 중 가장 가까운 원소는 5이고, 정답은 1.
////5보다 큰 원소는 없으므로 정답은 - 1.
////4보다 큰 원소 중 가장 가까운 원소는 5이므로, 정답은 1.
////1보다 큰 원소 중 가장 가까운 원소는 4, 2이고 인덱스는 각각 2, 4입니다.작은 인덱스를 선택해야 하므로 정답은 2.
////2보다 큰 원소 중 가장 가까운 원소는 4이고, 정답은 2.
////
////따라서 정답 배열은[1, -1, 1, 2, 2]입니다.